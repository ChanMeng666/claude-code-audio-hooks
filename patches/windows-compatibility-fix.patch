diff --git a/hooks/shared/hook_config.sh b/hooks/shared/hook_config.sh
index 1234567..abcdefg 100644
--- a/hooks/shared/hook_config.sh
+++ b/hooks/shared/hook_config.sh
@@ -7,6 +7,58 @@
 # CONFIGURATION PATHS
 # =============================================================================

+# =============================================================================
+# PYTHON COMMAND DETECTION (Windows Compatibility Fix)
+# =============================================================================
+
+# Smart Python command detector for cross-platform compatibility
+# This function tries multiple Python command names and validates Python 3
+get_python_cmd() {
+    # Return cached command if already detected
+    if [ -n "$CLAUDE_HOOKS_PYTHON_CMD" ]; then
+        echo "$CLAUDE_HOOKS_PYTHON_CMD"
+        return 0
+    fi
+
+    # Try different Python commands in order of preference
+    # python3: Linux/macOS standard
+    # python: Windows standard, some Linux with aliases
+    # py: Windows Python Launcher
+    for cmd in python3 python py; do
+        if command -v "$cmd" &> /dev/null; then
+            # Verify it's actually Python 3.x
+            local version=$("$cmd" --version 2>&1)
+            if [[ "$version" == *"Python 3"* ]]; then
+                export CLAUDE_HOOKS_PYTHON_CMD="$cmd"
+                echo "$cmd"
+                return 0
+            fi
+        fi
+    done
+
+    # Windows specific: try common installation paths
+    # Many Windows users install Python to custom locations
+    for py_pattern in \
+        "/c/Python3*/python.exe" \
+        "/c/Program Files/Python3*/python.exe" \
+        "/d/Python/Python3*/python.exe" \
+        "/c/Users/*/AppData/Local/Programs/Python/Python3*/python.exe"
+    do
+        # Use glob expansion to find actual paths
+        for actual_path in $py_pattern; do
+            if [ -f "$actual_path" ]; then
+                # Verify it's Python 3
+                local version=$("$actual_path" --version 2>&1)
+                if [[ "$version" == *"Python 3"* ]]; then
+                    export CLAUDE_HOOKS_PYTHON_CMD="$actual_path"
+                    echo "$actual_path"
+                    return 0
+                fi
+            fi
+        done
+    done
+
+    return 1
+}
+
 # Determine project directory (works from any hook script location)
 get_project_dir() {
     local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
@@ -63,7 +115,16 @@ LOCK_FILE="/tmp/claude_audio_hooks.lock"
 # Check if a hook is enabled in configuration
 is_hook_enabled() {
     local hook_type="$1"
+
+    # Get Python command (may return empty if not available)
+    local python_cmd=$(get_python_cmd)

+    # If no Python available, use hard-coded defaults
+    if [ -z "$python_cmd" ]; then
+        case "$hook_type" in
+            notification|stop|subagent_stop) return 0 ;;
+            *) return 1 ;;
+        esac
+    fi
+
     # If no config file exists, use defaults (notification, stop, subagent_stop enabled)
     if [ ! -f "$CONFIG_FILE" ]; then
         case "$hook_type" in
@@ -76,7 +137,7 @@ is_hook_enabled() {
     fi

     # Read enabled status from config using Python
-    local enabled=$(python3 <<EOF 2>/dev/null
+    local enabled=$("$python_cmd" <<EOF 2>/dev/null
 import json
 import sys
 try:
@@ -96,9 +157,16 @@ EOF
 get_audio_file() {
     local hook_type="$1"
     local default_file="$2"
+
+    # Get Python command
+    local python_cmd=$(get_python_cmd)

     # Try to read from config
-    if [ -f "$CONFIG_FILE" ]; then
+    if [ -f "$CONFIG_FILE" ] && [ -n "$python_cmd" ]; then
-        local audio_path=$(python3 <<EOF 2>/dev/null
+        local audio_path=$("$python_cmd" <<EOF 2>/dev/null
 import json
 try:
     with open("$CONFIG_FILE", "r") as f:
@@ -155,23 +223,22 @@ play_audio_internal() {
     # Git Bash / MSYS / MINGW (Windows Git Bash)
     elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "mingw"* ]]; then
-        # Convert Unix-style path to Windows path (e.g., /c/Users/... -> C:/Users/...)
+        # Convert Unix-style path to Windows path
         local win_path=$(echo "$audio_file" | sed 's|^/\([a-zA-Z]\)/|\U\1:/|')
-        if [ -n "$win_path" ]; then
-            # Create temporary PowerShell script to avoid escaping issues
-            local temp_ps1="/tmp/claude_audio_play_$$.ps1"
-            local temp_ps1_win=$(echo "$temp_ps1" | sed 's|^/\([a-zA-Z]\)/|\U\1:/|')
-
-            # Create PowerShell script
-            cat > "$temp_ps1" << 'PSEOF'
-Add-Type -AssemblyName presentationCore
-$mediaPlayer = New-Object System.Windows.Media.MediaPlayer
-$uri = New-Object System.Uri("file:///__AUDIOFILE__")
-$mediaPlayer.Open($uri)
-$mediaPlayer.Play()
-Start-Sleep -Seconds 3
-$mediaPlayer.Stop()
-$mediaPlayer.Close()
-PSEOF
-            # Replace placeholder with actual path
-            sed -i "s|__AUDIOFILE__|$win_path|g" "$temp_ps1" 2>/dev/null
-
-            # Execute PowerShell script and clean up in background
-            (powershell.exe -ExecutionPolicy Bypass -File "$temp_ps1_win" 2>/dev/null; rm -f "$temp_ps1" 2>/dev/null) &
+
+        # Use direct PowerShell command (no temp file needed)
+        # This is more reliable than creating temp files in Git Bash
+        powershell.exe -ExecutionPolicy Bypass -NoProfile -Command "
+            \$ErrorActionPreference = 'SilentlyContinue'
+            try {
+                Add-Type -AssemblyName presentationCore
+                \$uri = [uri]::new('file:///$win_path')
+                \$player = [System.Windows.Media.MediaPlayer]::new()
+                \$player.Open(\$uri)
+                \$player.Play()
+                Start-Sleep -Seconds 3
+                \$player.Stop()
+                \$player.Close()
+            } catch {
+                # Silent fail - hook errors should not block Claude
+            }
+        " 2>/dev/null &
             return 0
-        fi
     # Cygwin (another Windows compatibility layer)
     elif [[ "$OSTYPE" == "cygwin" ]]; then
@@ -245,9 +312,16 @@ init_queue() {

 # Check if queue is enabled
 is_queue_enabled() {
+    # Get Python command
+    local python_cmd=$(get_python_cmd)
+
+    # Default to enabled if no Python
+    if [ -z "$python_cmd" ]; then
+        return 0
+    fi
+
     if [ ! -f "$CONFIG_FILE" ]; then
         return 0  # Queue enabled by default
     fi

-    local queue_enabled=$(python3 <<EOF 2>/dev/null
+    local queue_enabled=$("$python_cmd" <<EOF 2>/dev/null
 import json
 try:
     with open("$CONFIG_FILE", "r") as f:
@@ -265,11 +339,18 @@ EOF

 # Get debounce milliseconds
 get_debounce_ms() {
+    # Get Python command
+    local python_cmd=$(get_python_cmd)
+
+    # Default to 500ms if no Python
+    if [ -z "$python_cmd" ]; then
+        echo "500"
+        return
+    fi
+
     if [ ! -f "$CONFIG_FILE" ]; then
         echo "500"  # Default 500ms
         return
     fi

-    python3 <<EOF 2>/dev/null
+    "$python_cmd" <<EOF 2>/dev/null
 import json
 try:
     with open("$CONFIG_FILE", "r") as f:
